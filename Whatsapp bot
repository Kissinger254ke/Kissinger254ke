// whatsapp-bot-allfeatures.js
/**
 * Full-feature WhatsApp bot:
 * - MongoDB logs
 * - Music (YouTube -> mp3, 5min cap)
 * - Anti-delete
 * - Export to CSV + ZIP, uploads to S3 (if configured)
 * - /announce (broadcast to groups), /kick (owner-only, in-group)
 * - ffmpeg preflight check + owner notification
 *
 * npm i whatsapp-web.js mongoose ytdl-core yt-search archiver @aws-sdk/client-s3
 * ffmpeg must be installed and on PATH
 */

const { Client, LocalAuth, MessageMedia } = require('whatsapp-web.js');
const mongoose = require('mongoose');
const ytdl = require('ytdl-core');
const ytSearch = require('yt-search');
const fs = require('fs');
const { spawn } = require('child_process');
const archiver = require('archiver');
const path = require('path');
const os = require('os');

const { S3Client, PutObjectCommand, GetObjectCommand, DeleteObjectCommand } = require('@aws-sdk/client-s3');
const stream = require('stream');
const { promisify } = require('util');
const pipeline = promisify(stream.pipeline);

// ====== CONFIG (ENV-friendly) ======
const OWNER = process.env.OWNER_JID || '254704917191@c.us';
const OWNER_NAME = process.env.OWNER_NAME || 'Kissinger254ke';
const MONGO_URI = process.env.MONGO_URI || 'mongodb+srv://kissingermwenda88_db_user:Iamkissinger254ke@cluster254.fzfqfsk.mongodb.net/?retryWrites=true&w=majority&appName=Cluster254';
const TEMP_DIR = path.join(os.tmpdir(), 'wa_bot_temp');
if (!fs.existsSync(TEMP_DIR)) fs.mkdirSync(TEMP_DIR, { recursive: true });

// S3 config (optional)
const AWS_REGION = process.env.AWS_REGION || null;
const S3_BUCKET = process.env.S3_BUCKET || null;
let s3Client = null;
if (process.env.AWS_ACCESS_KEY_ID && process.env.AWS_SECRET_ACCESS_KEY && AWS_REGION && S3_BUCKET) {
  s3Client = new S3Client({ region: AWS_REGION });
}

// ====== MONGO ======
mongoose.connect(MONGO_URI, { useNewUrlParser: true, useUnifiedTopology: true })
  .then(() => console.log('MongoDB connected'))
  .catch(err => console.error('MongoDB error', err));

// ====== SCHEMAS ======
const messageSchema = new mongoose.Schema({
  from: String,
  body: String,
  timestamp: { type: Date, default: Date.now }
});
const denialSchema = new mongoose.Schema({
  userId: String,
  chatId: String,
  command: String,
  denialLine: String,
  timestamp: { type: Date, default: Date.now }
});
const clearSchema = new mongoose.Schema({
  ownerId: String,
  chatId: String,
  clearedCount: Number,
  action: String, // full / partial
  timestamp: { type: Date, default: Date.now }
});
const exportSchema = new mongoose.Schema({
  type: String, // denials / clears
  count: Number,
  fileName: String,   // local path at creation time (may be cleaned later)
  s3Key: String,      // S3 key (if uploaded)
  s3Url: String,      // optional public url or presigned
  requestedBy: String,
  timestamp: { type: Date, default: Date.now }
});

const MessageLog = mongoose.model('Message', messageSchema);
const Denial = mongoose.model('Denial', denialSchema);
const Clear = mongoose.model('Clear', clearSchema);
const ExportLog = mongoose.model('Export', exportSchema);

// ====== TOGGLES & GUARDS ======
let antiDeleteActive = true;
let musicActive = true;
let groupAdminCommandsActive = true;
let activeDownloads = 0;
const MAX_CONCURRENT_DOWNLOADS = 2;

// ====== CLIENT ======
const client = new Client({ authStrategy: new LocalAuth() });

client.on('qr', qr => console.log('QR RECEIVED (scan to auth)'));
client.on('ready', async () => {
  console.log('WhatsApp bot is ready!');
  await runFfmpegPreflightAndNotifyOwner();
  // run an immediate export purge on start (non-blocking)
  autoPurgeExports().catch(err => console.error('Auto purge error', err));
});

// ====== FFmpeg preflight ======
function checkFfmpegAvailable() {
  return new Promise(resolve => {
    const p = spawn('ffmpeg', ['-version']);
    let ok = false;
    p.on('error', () => resolve(false));
    p.stdout.on('data', () => { ok = true; });
    p.on('close', code => resolve(ok && code === 0));
  });
}

async function runFfmpegPreflightAndNotifyOwner() {
  const ok = await checkFfmpegAvailable();
  if (!ok) {
    console.error('ffmpeg is not available in PATH ‚Äî music features will fail.');
    try {
      const ownerChat = await client.getChatById(OWNER);
      if (ownerChat) ownerChat.sendMessage('‚ö†Ô∏è ffmpeg not found on server. Music/download features will not work. Install ffmpeg and restart the bot.');
    } catch (e) {
      console.error('Failed notifying owner about ffmpeg missing', e);
    }
  } else {
    console.log('ffmpeg available.');
  }
}

// ====== CSV helpers & export ======
function csvEscape(val) {
  if (val === null || val === undefined) return '';
  const s = String(val).replace(/"/g, '""');
  return `"${s}"`;
}

async function exportToCSVZip(data, type, requester) {
  if (!Array.isArray(data)) data = [];
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const csvFile = path.join(TEMP_DIR, `${type}_export_${timestamp}.csv`);
  const zipFile = path.join(TEMP_DIR, `${type}_export_${timestamp}.zip`);

  if (data.length === 0) {
    fs.writeFileSync(csvFile, 'note\nNo entries\n', 'utf8');
  } else {
    const headers = Object.keys(data[0]);
    const rows = data.map(obj => headers.map(h => csvEscape(obj[h])).join(','));
    const csvContent = [headers.join(','), ...rows].join('\n');
    fs.writeFileSync(csvFile, csvContent, 'utf8');
  }

  await new Promise((resolve, reject) => {
    const output = fs.createWriteStream(zipFile);
    const archive = archiver('zip', { zlib: { level: 9 } });
    output.on('close', resolve);
    archive.on('error', reject);
    archive.pipe(output);
    archive.file(csvFile, { name: path.basename(csvFile) });
    archive.finalize();
  });

  try { fs.unlinkSync(csvFile); } catch (e) {}

  // Optionally upload to S3
  let s3Key = null;
  let s3Url = null;
  if (s3Client && S3_BUCKET) {
    try {
      s3Key = `exports/${path.basename(zipFile)}`;
      const bodyStream = fs.createReadStream(zipFile);
      await s3Client.send(new PutObjectCommand({
        Bucket: S3_BUCKET,
        Key: s3Key,
        Body: bodyStream
      }));
      // s3Url left as key ‚Äî you can create a presigned url if you want public access later
      s3Url = `s3://${S3_BUCKET}/${s3Key}`;
    } catch (e) {
      console.error('S3 upload failed', e);
      s3Key = null;
      s3Url = null;
    }
  }

  const exp = new ExportLog({
    type,
    count: data.length,
    fileName: zipFile,
    s3Key,
    s3Url,
    requestedBy: requester
  });
  await exp.save();

  return { zipFile, s3Key, s3Url, count: data.length };
}

// ====== AUTO PURGE (90 days) ======
async function autoPurgeExports() {
  const cutoff = new Date(Date.now() - 90 * 24 * 60 * 60 * 1000);
  const old = await ExportLog.find({ timestamp: { $lt: cutoff } });
  if (!old.length) return;
  // delete files locally and on s3
  for (const e of old) {
    try { if (e.fileName && fs.existsSync(e.fileName)) fs.unlinkSync(e.fileName); } catch (er) {}
    if (s3Client && e.s3Key) {
      try {
        await s3Client.send(new DeleteObjectCommand({ Bucket: S3_BUCKET, Key: e.s3Key }));
      } catch (er) { console.error('S3 delete failed', er); }
    }
  }
  const del = await ExportLog.deleteMany({ timestamp: { $lt: cutoff } });
  if (del.deletedCount > 0) {
    try {
      const ownerChat = await client.getChatById(OWNER);
      if (ownerChat) ownerChat.sendMessage(`üßπ Export log cleanup complete: ${del.deletedCount} old entries removed.`);
    } catch (e) {}
  }
}
setInterval(() => autoPurgeExports().catch(e => console.error(e)), 24 * 60 * 60 * 1000);

// ====== YouTube download helper ======
async function downloadYouTubeAudio(url, outFilename) {
  if (activeDownloads >= MAX_CONCURRENT_DOWNLOADS) throw new Error('Too many concurrent downloads');
  activeDownloads++;
  try {
    const info = await ytdl.getInfo(url);
    const audioStream = ytdl.downloadFromInfo(info, { quality: 'highestaudio' });

    const args = ['-i', 'pipe:0', '-t', '300', '-vn', '-ar', '44100', '-ac', '2', '-b:a', '192k', outFilename];
    const ffmpeg = spawn('ffmpeg', args);

    audioStream.pipe(ffmpeg.stdin);

    return await new Promise((resolve, reject) => {
      ffmpeg.on('close', code => {
        activeDownloads = Math.max(0, activeDownloads - 1);
        if (code === 0) resolve();
        else reject(new Error('ffmpeg exited with code ' + code));
      });
      ffmpeg.on('error', err => {
        activeDownloads = Math.max(0, activeDownloads - 1);
        reject(err);
      });
    });
  } finally {
    activeDownloads = Math.max(0, activeDownloads - 1);
  }
}

// ====== message revoke (anti-delete) ======
client.on('message_revoke_everyone', async (msg, revokedMsg) => {
  try {
    if (!antiDeleteActive) return;
    if (!revokedMsg) return;
    const from = revokedMsg.from || revokedMsg.author || msg.from;
    const body = revokedMsg.body || '<media>';
    const chat = await (msg.getChat ? msg.getChat() : client.getChatById(msg.from));
    if (chat) chat.sendMessage(`‚ùå Anti-Delete Active! Message from ${from}: "${body}"`);
  } catch (e) {
    console.error('anti-delete error', e);
  }
});

// ====== MESSAGE HANDLER ======
client.on('message', async msg => {
  try {
    const text = (msg.body || '').trim();
    if (!text) return;

    await new MessageLog({ from: msg.from, body: msg.body }).save();

    const isOwner = msg.from === OWNER;

    // Owner greeting
    if (isOwner && text.toLowerCase() === 'hi') return msg.reply(`Hello üëë ${OWNER_NAME}, your bot is at your service!`);

    if (text.toLowerCase() === '/help') {
      return msg.reply(
`ü§ñ Commands:
- /history
- /music <name/link>
- /announce <msg> (owner) - broadcasts to all groups
- /kick <number> (owner) - run in a group to remove a participant; bot must be admin
- /antidelete on/off/status (owner)
- /musiccmd on/off/status (owner)
- /denials export (owner)
- /clears export (owner)
- /exports history [n] (owner)
- /exports get <filename> (owner)
- /exports purge (owner)
- /exports purge all (owner)`
      );
    }

    // /history
    if (text.toLowerCase() === '/history') {
      const history = await MessageLog.find({ from: msg.from }).limit(5).sort({ timestamp: -1 });
      let reply = 'Your last 5 messages:\n';
      history.forEach(m => (reply += `- ${m.body}\n`));
      return msg.reply(reply);
    }

    // /music
    if (text.startsWith('/music')) {
      if (!musicActive) return msg.reply('üö´ Music commands are disabled.');
      const query = text.replace('/music', '').trim();
      if (!query) return msg.reply('‚ö†Ô∏è Provide a YouTube link or song name.');

      if (activeDownloads >= MAX_CONCURRENT_DOWNLOADS) return msg.reply('‚ö†Ô∏è Server busy with downloads. Try again shortly.');

      try {
        let url;
        if (ytdl.validateURL(query)) url = query;
        else {
          const search = await ytSearch(query);
          if (!search || !search.videos || !search.videos.length) return msg.reply('‚ùå No results found.');
          url = search.videos[0].url;
        }

        const info = await ytdl.getInfo(url);
        const title = info.videoDetails.title || 'Unknown';
        const thumbnail = (info.videoDetails.thumbnails || []).slice(-1)[0];

        if (thumbnail && thumbnail.url) {
          try {
            const thumb = await MessageMedia.fromUrl(thumbnail.url);
            await client.sendMessage(msg.from, thumb, { caption: `üéµ ${title} (5min cap)` });
          } catch (e) { await msg.reply(`üéµ ${title} (5min cap)`); }
        } else {
          await msg.reply(`üéµ ${title} (5min cap)`);
        }

        const filename = path.join(TEMP_DIR, `temp_${Date.now()}.mp3`);
        await msg.reply('‚è¨ Downloading...');
        await downloadYouTubeAudio(url, filename);
        const audio = MessageMedia.fromFilePath(filename);
        await client.sendMessage(msg.from, audio);
        try { fs.unlinkSync(filename); } catch (e) {}
      } catch (e) {
        console.error('music error', e);
        return msg.reply('‚ùå Error fetching music: ' + (e.message || 'unknown'));
      }
      return;
    }

    // ====== OWNER: announce (broadcast to all group chats) ======
    if (isOwner && text.startsWith('/announce ')) {
      const announcement = text.replace('/announce ', '').trim();
      if (!announcement) return msg.reply('‚ö†Ô∏è Provide a message to announce.');
      await msg.reply('üì° Broadcasting announcement to groups...');
      try {
        const chats = await client.getChats();
        const groupChats = chats.filter(c => c.isGroup);
        let sent = 0;
        for (const gc of groupChats) {
          try {
            await gc.sendMessage(`üì¢ Announcement from ${OWNER_NAME}:\n\n${announcement}`);
            sent++;
          } catch (e) {
            console.error('announce failed for', gc.id._serialized, e);
          }
        }
        return msg.reply(`‚úÖ Announcement sent to ${sent} group(s).`);
      } catch (e) {
        console.error('announce error', e);
        return msg.reply('‚ùå Failed to broadcast announcement.');
      }
    }

    // ====== OWNER: kick (must be used in a group chat) ======
    if (isOwner && text.startsWith('/kick ')) {
      const parts = text.split(' ').filter(Boolean);
      if (parts.length < 2) return msg.reply('‚ö†Ô∏è Usage: /kick <phoneWithCountry> e.g. 2547xxxxxxx');
      const targetNum = parts[1].replace(/\D/g, '');
      if (!targetNum) return msg.reply('‚ö†Ô∏è Invalid number.');
      // Only allowed inside a group
      const chat = await msg.getChat();
      if (!chat.isGroup) return msg.reply('‚ö†Ô∏è Use /kick inside the group where you want the person removed.');
      // bot must be admin to remove
      const me = await chat.getContact();
      const botIsAdmin = chat.participants && chat.participants.some(p => p.id._serialized === client.info.wid._serialized && p.isAdmin);
      if (!botIsAdmin) return msg.reply('‚ùå I need to be a group admin to remove participants.');
      // build jid
      const jid = `${targetNum}@c.us`;
      try {
        await chat.removeParticipants([jid]);
        await msg.reply(`‚úÖ Removed ${targetNum} from the group (if present).`);
        // optional: log the clear
        await new Clear({ ownerId: msg.from, chatId: chat.id._serialized, clearedCount: 1, action: 'kick' }).save();
      } catch (e) {
        console.error('kick failed', e);
        return msg.reply('‚ùå Failed to remove participant. Are they in the group?');
      }
      return;
    }

    // ====== EXPORTS (owner only) ======
    if (isOwner && text.startsWith('/denials export')) {
      try {
        const data = await Denial.find().lean();
        const { zipFile, s3Key, s3Url, count } = await exportToCSVZip(data, 'denials', msg.from);
        // If uploaded to s3, prefer sending a small message with S3 key, but also send file if local exists
        if (zipFile && fs.existsSync(zipFile)) {
          const media = MessageMedia.fromFilePath(zipFile);
          await client.sendMessage(msg.from, media, { caption: `üìÇ Denials export: ${count} entries` });
          try { fs.unlinkSync(zipFile); } catch (e) {}
        } else if (s3Key) {
          await msg.reply(`üìÇ Denials uploaded to S3: ${s3Key}`);
        } else {
          await msg.reply('‚ùå Export failed.');
        }
      } catch (e) {
        console.error('denials export', e);
        await msg.reply('‚ùå Failed to export denials.');
      }
      return;
    }

    if (isOwner && text.startsWith('/clears export')) {
      try {
        const data = await Clear.find().lean();
        const { zipFile, s3Key, count } = await exportToCSVZip(data, 'clears', msg.from);
        if (zipFile && fs.existsSync(zipFile)) {
          const media = MessageMedia.fromFilePath(zipFile);
          await client.sendMessage(msg.from, media, { caption: `üìÇ Clears export: ${count} items` });
          try { fs.unlinkSync(zipFile); } catch (e) {}
        } else if (s3Key) {
          await msg.reply(`üìÇ Clears uploaded to S3: ${s3Key}`);
        } else {
          await msg.reply('‚ùå Export failed.');
        }
      } catch (e) {
        console.error('clears export', e);
        await msg.reply('‚ùå Failed to export clears.');
      }
      return;
    }

    if (isOwner && text.startsWith('/exports history')) {
      let n = 5;
      const parts = text.split(' ').filter(Boolean);
      if (parts[2]) n = Math.min(parseInt(parts[2]) || 5, 50);
      const exports = await ExportLog.find().sort({ timestamp: -1 }).limit(n);
      let reply = `üìú Export History (latest ${exports.length}):\n`;
      const cutoff = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
      exports.forEach((e, i) => {
        const old = e.timestamp < cutoff ? ' ‚ö†Ô∏è 30+ days old' : '';
        reply += `${i + 1}. [${e.timestamp.toISOString()}] ${e.type} ‚Üí ${e.count} ‚Üí ${path.basename(e.fileName || e.s3Key || '')}${old}\n`;
      });
      return msg.reply(reply);
    }

    if (isOwner && text.startsWith('/exports get')) {
      const parts = text.split(' ').filter(Boolean);
      const name = parts[2];
      if (!name) return msg.reply('‚ö†Ô∏è Usage: /exports get <partial-file-or-key>');
      const rec = await ExportLog.findOne({ $or: [{ fileName: { $regex: name, $options: 'i' } }, { s3Key: { $regex: name, $options: 'i' } }] });
      if (!rec) return msg.reply('‚ùå Export not found.');

      // If local file exists, send it
      if (rec.fileName && fs.existsSync(rec.fileName)) {
        try {
          const media = MessageMedia.fromFilePath(rec.fileName);
          await client.sendMessage(msg.from, media, { caption: `üìÇ Re-sent: ${path.basename(rec.fileName)}` });
          return;
        } catch (e) {
          console.error('sending local file failed', e);
        }
      }

      // otherwise, try to fetch from S3
      if (s3Client && rec.s3Key) {
        try {
          const tmp = path.join(TEMP_DIR, `dl_${Date.now()}_${path.basename(rec.s3Key)}`);
          const getObj = await s3Client.send(new GetObjectCommand({ Bucket: S3_BUCKET, Key: rec.s3Key }));
          await pipeline(getObj.Body, fs.createWriteStream(tmp));
          const media = MessageMedia.fromFilePath(tmp);
          await client.sendMessage(msg.from, media, { caption: `üìÇ Re-sent from S3: ${path.basename(rec.s3Key)}` });
          try { fs.unlinkSync(tmp); } catch (e) {}
          return;
        } catch (e) {
          console.error('S3 download/send failed', e);
          return msg.reply('‚ùå Failed to retrieve export from S3.');
        }
      }

      return msg.reply('‚ùå Export file missing on server and not available in S3.');
    }

    if (isOwner && text === '/exports purge') {
      const cutoff = new Date(Date.now() - 90 * 24 * 60 * 60 * 1000);
      const old = await ExportLog.find({ timestamp: { $lt: cutoff } });
      for (const e of old) {
        try { if (e.fileName && fs.existsSync(e.fileName)) fs.unlinkSync(e.fileName); } catch (er) {}
        if (s3Client && e.s3Key) {
          try { await s3Client.send(new DeleteObjectCommand({ Bucket: S3_BUCKET, Key: e.s3Key })); } catch (er) {}
        }
      }
      const rem = await ExportLog.deleteMany({ timestamp: { $lt: cutoff } });
      return msg.reply(`üßπ Manual purge complete: ${rem.deletedCount} old export logs removed.`);
    }

    if (isOwner && text === '/exports purge all') {
      const all = await ExportLog.find();
      for (const e of all) {
        try { if (e.fileName && fs.existsSync(e.fileName)) fs.unlinkSync(e.fileName); } catch (er) {}
        if (s3Client && e.s3Key) {
          try { await s3Client.send(new DeleteObjectCommand({ Bucket: S3_BUCKET, Key: e.s3Key })); } catch (er) {}
        }
      }
      const rem = await ExportLog.deleteMany({});
      return msg.reply(`üóëÔ∏è Full purge complete: ${rem.deletedCount} export logs removed.`);
    }

    // admin toggles
    if (isOwner && text.startsWith('/antidelete')) {
      const parts = text.split(' ').filter(Boolean);
      if (parts[1] === 'on') antiDeleteActive = true;
      else if (parts[1] === 'off') antiDeleteActive = false;
      else if (parts[1] === 'status